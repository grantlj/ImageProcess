function [] = main_trainer()
vl_setupnn;
f=1/100;
net_split_position=[2,5,7,8];

net.layers = {} ;
net.layers{end+1} = struct('type', 'conv', ...
                           'filters', f*randn(5,5,3,20, 'single'), ...
                           'biases', zeros(1, 20, 'single'), ...
                           'stride', 1, ...
                           'pad', 0) ;
net.layers{end+1} = struct('type', 'pool', ...
                           'method', 'max', ...
                           'pool', [2 2], ...
                           'stride', 2, ...
                           'pad', 0) ;
net.layers{end+1} = struct('type', 'conv', ...
                           'filters', f*randn(5,5,20,50, 'single'),...
                           'biases', zeros(1,50,'single'), ...
                           'stride', 1, ...
                           'pad', 0) ;
net.layers{end+1} = struct('type', 'relu');
net.layers{end+1} = struct('type', 'pool', ...
                           'method', 'max', ...
                           'pool', [2 2], ...
                           'stride', 2, ...
                           'pad', 0) ;
net.layers{end+1} = struct('type', 'conv', ...
                           'filters', f*randn(4,4,50,500, 'single'),...
                           'biases', zeros(1,500,'single'), ...
                           'stride', 1, ...
                           'pad', 0) ;
net.layers{end+1} = struct('type', 'relu') ;

net.layers{end+1} = struct('type', 'conv', ...
                           'filters', f*randn(1,1,500,500, 'single'),...
                           'biases', zeros(1,500,'single'), ...
                           'stride', 1, ...
                           'pad', 0) ;

net.layers{end+1} = struct('type', 'dropout', ...
                           'rate', 0.5) ;

net.layers{end+1} = struct('type', 'conv', ...
                           'filters', f*randn(1,1,500,2, 'single'),...
                           'biases', zeros(1,2,'single'), ...
                           'stride', 1, ...
                           'pad', 0) ;


%%

%input configuration, to generate random image.
im_height=28; im_width=28; chl=3;class_count=2;
im_tmp=single(rand(im_height,im_width,chl));

for i=1:size(net_split_position,2)
  
 
  %obtain the feature map size of the present last layer.
  present_last_layer=net_split_position(i);
  present_net.layers=net.layers(1:present_last_layer);  
  filename=['present_net_layer_',num2str(present_last_layer),'.mat'];
  res=vl_simplenn(net,im_tmp);
  present_feature_map_size=size(res(present_last_layer+1).x);
  
  present_net.layers{end+1}=struct('type', 'conv', ...
                           'filters', f*randn(present_feature_map_size(1),present_feature_map_size(2),present_feature_map_size(3),128, 'single'),...
                           'biases', zeros(1,128,'single'), ...
                           'stride', 1, ...
                           'pad', 0) ;
                       
  present_net.layers{end+1}= struct('type', 'conv', ...
                           'filters', f*randn(1,1,128,class_count, 'single'),...
                           'biases', zeros(1,2,'single'), ...
                           'stride', 1, ...
                           'pad', 0) ;   
                       
  present_net.layers{end+1}= struct('type', 'softmaxloss') ;
  
  if (i==1) 
    en_layer=-1;
  else
    en_layer=net_split_position(i-1);
  end
  [net_trained]=cnn_head(present_net,en_layer);
  
  %save back to net.
  net.layers(1:present_last_layer)=net_trained.layers(1:present_last_layer);
  
 
  save(filename,'net_trained');
 
end

end

